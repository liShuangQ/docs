import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as s,c as a,b as e}from"./app-DtJgIU74.js";const t="/docs/assets/image-DolcpbzK.png",i="/docs/assets/image-1-Ba-3Y_9U.png",o="/docs/assets/image-2-CgtEnu4b.png",p="/docs/assets/image-3-4N2aCA1s.png",l="/docs/assets/image-4-DtIgIHKE.png",c="/docs/assets/image-5-DIgcpGr1.png",r="/docs/assets/image-6-CAAvjSAU.png",u="/docs/assets/image-7-B4iZDHX_.png",d={},m=e('<h2 id="为什么会跨域" tabindex="-1"><a class="header-anchor" href="#为什么会跨域"><span>为什么会跨域</span></a></h2><p>浏览器的同源策略，跨域也是因为浏览器这个机制引起的，这个机制的存在还是在于安全。</p><h3 id="什么是源" tabindex="-1"><a class="header-anchor" href="#什么是源"><span>什么是源</span></a></h3><p><code>Web内容的源由用于访问它的URL 的方案(协议)，主机(域名)和端口定义。只有当方案，主机和端口都匹配时，两个对象具有相同的起源。</code> 同源不同源一句话就可以判断：就是 url 中 scheme host port 都相同即为同源。 下面认识下 url 结构中的这三个部分。</p><h3 id="url-结构" tabindex="-1"><a class="header-anchor" href="#url-结构"><span>URL 结构</span></a></h3><p><code>URL 代表着是统一资源定位符（Uniform Resource Locator）。URL 无非就是一个给定的独特资源在 Web 上的地址。</code> URL 有如下结构组成：</p><ul><li><p>Schme 或者 Protocol</p><figure><img src="'+t+'" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure></li><li><p>Domain Name 也叫做 host 域名</p><figure><img src="'+i+'" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure></li><li><p>port 端口号</p><figure><img src="'+o+'" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure></li><li><p>Parameters 参数</p><figure><img src="'+p+'" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure></li><li><p>Anchor 锚点，一般用于定位位置</p><figure><img src="'+l+'" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure></li></ul><h3 id="同源不同源的例子" tabindex="-1"><a class="header-anchor" href="#同源不同源的例子"><span>同源不同源的例子</span></a></h3><ul><li>同源例子 <ul><li>http://example.com/app1/index.html http://example.com/app2/index.html相同的scheme http 和 host</li><li>http://Example.com:80 http://example.comhttp 默认 80 端口所以同源</li></ul></li><li>不同源例子 <ul><li>http://example.com/app1 https://example.com/app2不同的协议</li><li>http://example.com http://myapp.example.com不同的host</li><li>http://example.com http://example.com:8080不同的端口</li></ul></li></ul><h3 id="浏览器为什么需要同源策略" tabindex="-1"><a class="header-anchor" href="#浏览器为什么需要同源策略"><span>浏览器为什么需要同源策略</span></a></h3><p>同源策略是一个重要的安全策略，它用于限制一个 origin 的文档或者它加载的脚本如何能与另一个源的资源进行交互。它能帮助阻隔恶意文档，减少可能被攻击的媒介。</p><h2 id="前端解决方案" tabindex="-1"><a class="header-anchor" href="#前端解决方案"><span>前端解决方案</span></a></h2><p>在没有前后端分离的时候，跨域问题往往是很少的。因为前后端都部署到一起。现在前后端分离不管 vue /react 面临跨域请求的问题。 下面是引用官网描述的一张图来解释跨域：</p><figure><img src="'+c+'" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure><p>跨源域资源共享（CORS）机制允许 Web 应用服务器进行跨源访问控制，从而使跨源数据传输得以安全进行。现代浏览器支持在 API 容器中（例如 XMLHttpRequest 或 Fetch）使用 CORS，以降低跨源 HTTP 请求所带来的风险。</p><h3 id="jsonp" tabindex="-1"><a class="header-anchor" href="#jsonp"><span>jsonp</span></a></h3><p>JSONP 的原理非常简单，就是 HTML 标签中，很多带 src 属性的标签都可以跨域请求内容，比如我们熟悉的 img 图片标签。同理，script 标签也可以，可以利用 script 标签来执行跨域的 javascript 代码。通过这些代码，我们就能实现前端跨域请求数据。 jsonp 可以在前端解决跨域问题，但是只是针对于 get 请求。实现方式可以引用一些 npm 第三方库实现，jquery 也是带的。 可以在 npm 搜下 jsonp 库实现，非常简单。</p><figure><img src="'+r+`" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure><h3 id="webpack-dev-server" tabindex="-1"><a class="header-anchor" href="#webpack-dev-server"><span>webpack-dev-server</span></a></h3><p>前端无论是 vue 项目还是 react 项目大多数都会以 webpack-dev-server 来运行，webpack-dev-server 可以设置代理，前端可以在开发环境设置代理解决跨域问题。</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code> <span class="token literal-property property">proxy</span><span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token string-property property">&#39;/api&#39;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
        <span class="token literal-property property">target</span><span class="token operator">:</span> <span class="token string">&#39;http://localhost:3000&#39;</span><span class="token punctuation">,</span>
        <span class="token literal-property property">pathRewrite</span><span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token string-property property">&#39;^/api&#39;</span><span class="token operator">:</span> <span class="token string">&#39;&#39;</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token literal-property property">changeOrigin</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
   <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="document-domain" tabindex="-1"><a class="header-anchor" href="#document-domain"><span>document.domain</span></a></h3><p>利用 document.domain 可以修改 访问页面的域，多用在父子关系的域，子域可以设置 document.domain 等于父域，从而解决同父域跨域问题。 举例子： www.ios.xingyu.com 访问 www.web.xingyu.com 跨域，可以利用 document.domain 设置成 www.xingyu.com</p><h2 id="后端解决方案" tabindex="-1"><a class="header-anchor" href="#后端解决方案"><span>后端解决方案</span></a></h2><p>后端框架也很多，实现原理差不多，都是修改下相应头。以常用的Java SpringCloud 和nodejs koa 框架为例。</p><h3 id="http-协议cors头" tabindex="-1"><a class="header-anchor" href="#http-协议cors头"><span>Http 协议CORS头</span></a></h3><p>跨域其实也是http层面上可以解决的问题，后端解决也是比较简单的，也是项目常见的解决手法。 CORS （Cross-Origin Resource Sharing，跨域资源共享）是一个系统，它由一系列传输的HTTP头组成，这些HTTP头决定浏览器是否阻止前端 JavaScript 代码获取跨域请求的响应。 同源安全策略 默认阻止“跨域”获取资源。但是 CORS 给了web服务器这样的权限，即服务器可以选择，允许跨域请求访问到它们的资源。</p><ul><li>Access-Control-Allow-Origin 指示请求的资源能共享给哪些域。</li><li>Access-Control-Allow-Credentials 指示当请求的凭证标记为 true 时，是否响应该请求。</li><li>Access-Control-Allow-Headers 用在对预请求的响应中，指示实际的请求中可以使用哪些 HTTP 头。</li><li>Access-Control-Allow-Methods 指定对预请求的响应中，哪些 HTTP 方法允许访问请求的资源。</li><li>Access-Control-Expose-Headers 指示哪些 HTTP 头的名称能在响应中列出。</li><li>Access-Control-Max-Age 指示预请求的结果能被缓存多久。</li><li>Access-Control-Request-Headers 用于发起一个预请求，告知服务器正式请求会使用那些 HTTP 头。</li><li>Access-Control-Request-Method 用于发起一个预请求，告知服务器正式请求会使用哪一种 HTTP 请求方法。</li><li>Origin 指示获取资源的请求是从什么域发起的。</li></ul><h3 id="springcloud设置跨域" tabindex="-1"><a class="header-anchor" href="#springcloud设置跨域"><span>SpringCloud设置跨域</span></a></h3><p>在跨域过滤器里配置一下跨域头部，* 是通配符即允许所有。</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token annotation punctuation">@Configuration</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GatewayCorsConfiguation</span> <span class="token punctuation">{</span>
 
    <span class="token annotation punctuation">@Bean</span>
    <span class="token keyword">public</span> <span class="token class-name">CorsFilter</span> <span class="token function">corsFilter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment">// 初始化cors配置对象</span>
        <span class="token class-name">CorsConfiguration</span> configuration <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CorsConfiguration</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        configuration<span class="token punctuation">.</span><span class="token function">setAllowCredentials</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 允许使用cookie，但是使用cookie是addAllowedOrigin必须是具体的地址，不能是*</span>
<span class="token comment">//        configuration.addAllowedOrigin(&quot;*&quot;);</span>
        configuration<span class="token punctuation">.</span><span class="token function">addAllowedOrigin</span><span class="token punctuation">(</span><span class="token string">&quot;http://manage.leyou.com&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        configuration<span class="token punctuation">.</span><span class="token function">addAllowedMethod</span><span class="token punctuation">(</span><span class="token string">&quot;*&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//允许的请求方式,get,put,post,delete</span>
        configuration<span class="token punctuation">.</span><span class="token function">addAllowedHeader</span><span class="token punctuation">(</span><span class="token string">&quot;*&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//允许的头信息</span>
 
        <span class="token comment">//初始化cors的源对象配置</span>
        <span class="token class-name">UrlBasedCorsConfigurationSource</span> corsConfigurationSource <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">UrlBasedCorsConfigurationSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        corsConfigurationSource<span class="token punctuation">.</span><span class="token function">registerCorsConfiguration</span><span class="token punctuation">(</span><span class="token string">&quot;/**&quot;</span><span class="token punctuation">,</span>configuration<span class="token punctuation">)</span><span class="token punctuation">;</span>
 
        <span class="token comment">//3.返回新的CorsFilter.</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">CorsFilter</span><span class="token punctuation">(</span>corsConfigurationSource<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="springboot配置" tabindex="-1"><a class="header-anchor" href="#springboot配置"><span>SpringBoot配置</span></a></h3><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token doc-comment comment">/**
 * 跨域配置
 */</span>
<span class="token annotation punctuation">@Configuration</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CorsConfig</span> <span class="token keyword">implements</span> <span class="token class-name">WebMvcConfigurer</span> <span class="token punctuation">{</span>

   <span class="token doc-comment comment">/**
    * 跨域注册器
    *
    * <span class="token keyword">@param</span> <span class="token parameter">registry</span> 跨域注册器
    */</span>
   <span class="token annotation punctuation">@Override</span>
   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addCorsMappings</span><span class="token punctuation">(</span><span class="token class-name">CorsRegistry</span> registry<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       
      <span class="token comment">// 设置允许跨域的路径</span>
      registry<span class="token punctuation">.</span><span class="token function">addMapping</span><span class="token punctuation">(</span><span class="token string">&quot;/**&quot;</span><span class="token punctuation">)</span>
            <span class="token comment">// 设置允许跨域请求的域名</span>
            <span class="token punctuation">.</span><span class="token function">allowedOrigins</span><span class="token punctuation">(</span><span class="token string">&quot;*&quot;</span><span class="token punctuation">)</span>
            <span class="token comment">// 是否允许证书 不再默认开启</span>
            <span class="token punctuation">.</span><span class="token function">allowCredentials</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>
            <span class="token comment">// 设置允许的方法</span>
            <span class="token punctuation">.</span><span class="token function">allowedMethods</span><span class="token punctuation">(</span><span class="token string">&quot;*&quot;</span><span class="token punctuation">)</span>
            <span class="token comment">// 设置允许的头</span>
            <span class="token punctuation">.</span><span class="token function">allowedHeaders</span><span class="token punctuation">(</span><span class="token string">&quot;*&quot;</span><span class="token punctuation">)</span>
            <span class="token comment">// 跨域允许时间</span>
            <span class="token punctuation">.</span><span class="token function">maxAge</span><span class="token punctuation">(</span><span class="token number">3600</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="运维解决方案" tabindex="-1"><a class="header-anchor" href="#运维解决方案"><span>运维解决方案</span></a></h2><p>ngnix举例，其他web 服务器就不说了，原理同webpack-dev-server 设置代理转发解决跨域问题。 步骤：</p><ul><li>前端和运维商量好协议路径代理规则，比如/api 代表域名</li><li>前端配置webpack -dev -server 代理</li><li>服务器利用ngnix 配置相同转发代理 ngnix 配置代理解决跨域配置：</li></ul><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>location /api {
   proxy_pass https://b.test.com; # 设置代理服务器的协议和地址
} 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="`+u+'" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure>',38),k=[m];function v(g,h){return s(),a("div",null,k)}const x=n(d,[["render",v],["__file","跨域.html.vue"]]),w=JSON.parse('{"path":"/front-end/browser/%E6%9C%BA%E5%88%B6/%E8%B7%A8%E5%9F%9F.html","title":"跨域介绍和处理","lang":"zh-CN","frontmatter":{"title":"跨域介绍和处理","category":["浏览器"],"tag":["浏览器"]},"headers":[{"level":2,"title":"为什么会跨域","slug":"为什么会跨域","link":"#为什么会跨域","children":[{"level":3,"title":"什么是源","slug":"什么是源","link":"#什么是源","children":[]},{"level":3,"title":"URL 结构","slug":"url-结构","link":"#url-结构","children":[]},{"level":3,"title":"同源不同源的例子","slug":"同源不同源的例子","link":"#同源不同源的例子","children":[]},{"level":3,"title":"浏览器为什么需要同源策略","slug":"浏览器为什么需要同源策略","link":"#浏览器为什么需要同源策略","children":[]}]},{"level":2,"title":"前端解决方案","slug":"前端解决方案","link":"#前端解决方案","children":[{"level":3,"title":"jsonp","slug":"jsonp","link":"#jsonp","children":[]},{"level":3,"title":"webpack-dev-server","slug":"webpack-dev-server","link":"#webpack-dev-server","children":[]},{"level":3,"title":"document.domain","slug":"document-domain","link":"#document-domain","children":[]}]},{"level":2,"title":"后端解决方案","slug":"后端解决方案","link":"#后端解决方案","children":[{"level":3,"title":"Http 协议CORS头","slug":"http-协议cors头","link":"#http-协议cors头","children":[]},{"level":3,"title":"SpringCloud设置跨域","slug":"springcloud设置跨域","link":"#springcloud设置跨域","children":[]},{"level":3,"title":"SpringBoot配置","slug":"springboot配置","link":"#springboot配置","children":[]}]},{"level":2,"title":"运维解决方案","slug":"运维解决方案","link":"#运维解决方案","children":[]}],"git":{"createdTime":1713621280000,"updatedTime":1713857586000,"contributors":[{"name":"liShuangQ-pc","email":"li_shuangq@foxmail.com","commits":1},{"name":"shuangqi.li","email":"li_shuangq@foxmail.com","commits":1}]},"readingTime":{"minutes":5.33,"words":1598},"filePathRelative":"front-end/browser/机制/跨域.md","localizedDate":"2024年4月20日"}');export{x as comp,w as data};
